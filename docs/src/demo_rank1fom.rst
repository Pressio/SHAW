(1): Single Forcing
===================

Below we assume you already completed one of the builds described in the build tab.
For simplicity, look at the serial step-by-step build guide.

Prepare environment
-------------------

.. code-block:: bash

   export ESWSRCDIR=<fullpath-to-the-source-code-repository>
   export SHAWEXEDIR=<fullpath-to-where-you-built-the-code-executables>

   # create a dir to run the demo
   export MYRUNDIR=${HOME}/myFirstDemo
   mkdir -p ${MYRUNDIR}


Generating the mesh
-------------------

For this demo, we use a grid of ``200`` x ``1000`` velocity points
along the radial and polar directions, respectively.
To generate the mesh files proceed as follows:

.. code-block:: bash

   cd ${ESWSRCDIR}/meshing
   python create_single_mesh.py -nr 200 -nth 1000 -working-dir ${MYRUNDIR}

Note that the grid generator script only needs the velocity points
because the stress points are defined automatically
based on the `staggered scheme <{filename}/goveq.rst>`_.

After generating the grid, you should have a ``${MYRUNDIR}/mesh200x1000`` directory containing:

.. code-block:: bash

   .
   ├── [4.5M]  coeff_vp.dat
   ├── [ 28M]  graph_sp.dat
   ├── [ 16M]  graph_vp.dat
   └── [ 231]  mesh_info.dat


Input file
----------

We use the following input file (`learn more about input file <{filename}/inputfile.rst>`_):

.. code-block:: yaml

   general:
     # meshDir should contain the full path to the mesh directory
     # as generated by the python script `meshing/create_single_mesh.py`
     # we assume the input file is in the same location as mesh dir
     meshDir: ./mesh200x1000
     dt: 0.25
     finalTime: 2000.0
     checkNumericalDispersion: true
     checkCfl: true

   io:
     snapshotMatrix:
       binary: true
       velocity: {freq: 100, fileName: snaps_vp}
       stress:   {freq: 100, fileName: snaps_sp}
     seismogram:
       binary: false
       freq: 4
       receivers: [5,30,55,80,105,130,155,175]

   source:
     signal:
       kind: ricker
       depth: 640.0  # km
       period: 65.0  # seconds
       delay: 180.0  # seconds

   material:
     kind: prem

You can get the input file as:

.. code-block:: bash

   cp ${ESWSRCDIR}/demos/fom_rank1/input.yaml ${MYRUNDIR}

Run the simulation
------------------


.. code-block:: bash

   cd ${MYRUNDIR}
   ln -s ${SHAWEXEDIR}/shawExe .

   # if you use OpenMP build, remember to set
   # OMP_NUM_THREADS=how-many-you-want-use OMP_PLACES=threads OMP_PROC_BIND=spread
   ./shawExe input.yaml


Simulation data
---------------

The demo should generate inside ``${MYRUNDIR}`` the following:

.. code-block:: bash

   coords_sp.txt #: coordinates of the velocity grid points
   coords_vp.txt #: coordinates of the stresses grid points
   seismogram_0  #: seismogram at the receiver locations set in input.yaml
   snaps_vp_0    #: snapshot matrix for the velocity
   snaps_sp_0    #: snapshot matrix for the stresses


Post-process data
-----------------

To post-process the data, you can use the Python scripts created for this demo:

.. code-block:: bash

   cp ${ESWSRCDIR}/demos/fom_rank1/*.py ${MYRUNDIR}


First, we visualize the seismogram data by doing:

.. code-block:: bash

   cd ${MYRUNDIR}
   python plotSeismogram.py


.. image:: ../img/demo1_f1.png


Then, we can extract and visualize the full wavefield at ``t=250, 1000, 2000`` (seconds):

.. code-block:: bash

   cd ${MYRUNDIR}
   ln -s ${SHAWEXEDIR}/extractStateFromSnaps .

   # extract from the velocity snapshots the velocity field at specific timesteps:
   # since we use ``dt = 0.25`` seconds, our tartgets ``t=250, 1000, 2000``,
   # correspond to *time steps* 1000, 4000, 8000
   ./extractStateFromSnaps --snaps=./snaps_vp_0 binary --fsize=1 \
     --outformat=ascii --timesteps=1000 4000 8000  --samplingfreq=100 --outfileappend=vp

   python plotWavefield.py


.. image:: ../img/demo1_f2.png
   :width: 30%
.. image:: ../img/demo1_f3.png
   :width: 28%
.. image:: ../img/demo1_f4.png
   :width: 30%
