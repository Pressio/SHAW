Rank-1 FOM Demo
###############

:breadcrumb: {filename}/rank1fom.rst
:summary: Running a rank-1 FOM

.. container::

   This demo shows step-by-step how to create and run a rank-1 full-order model simulation.

   Here we assume you already followed the `step-by-step guide <{filename}/getstarted/build_kokkos_host_serial.rst>`_
   to build the code and used ``MYWORKDIR`` as the working directory for that procedure,
   so that ``${MYWORKDIR}/build`` contains all the executables.

`1. Prepare environment`_
=========================

.. code:: bash

   # ensure this env var points to the build directory
   export MYWORKDIR=<the-same-work-directory-used-for-building-process>

   export ESWSRCDIR=<path-to-the-source-code-repository>
   export MYRUNDIR=${MYWORKDIR}/myFirstRun
   mkdir -p ${MYRUNDIR}


`2. Generating the mesh`_
=========================

The code has been developed such that the mesh is generated with Python
and is used by the C++ code. There are two main reasons for this choice:
first, it allows us to decouple the mesh generation from the actual physics code;
second, we developed the code to support the concept of sample mesh,
which is a key feature for nonlinear ROMs. This is **not** needed right now
to solve the current elastic shear wave problem because this is a linear problem,
but it can be useful if, in the future, we extend the code to support nonlinear problems.

To specify the grid, one only needs to specify the grid for the velocity points because
the stress points are defined based on the staggered scheme (see paper).
For this demo, we use a grid of ``200`` x ``1000`` velocity points
along the radial and polar directions, respectively.
To generate the mesh files proceed as follows:

.. code:: bash

   cd ${ESWSRCDIR}/meshing
   python create_single_mesh.py -nr 200 -nth 1000 -working-dir ${MYRUNDIR}


This should generate a directory ``${MYRUNDIR}/mesh200x1000`` containing:

.. code:: bash

   -rw-r--r--  1 fnrizzi  staff   4.5M Aug 30 12:20 coeff_vp.dat
   -rw-r--r--  1 fnrizzi  staff    28M Aug 30 12:20 graph_sp.dat
   -rw-r--r--  1 fnrizzi  staff    16M Aug 30 12:20 graph_vp.dat
   -rw-r--r--  1 fnrizzi  staff   231B Aug 30 12:20 mesh_info.dat


`3. Input file`_
================

Input files are based on yaml.
For this demo, we use the following input file:

.. code:: yaml

   general:
     # meshDir should contain the full path to the mesh directory
     # as generated by the python script `meshing/create_single_mesh.py`
     # but here we use this for simplicity since this input file
     # is used in the doc showing how to run a case
     meshDir: ./mesh200x1000
     dt: 0.25
     finalTime: 2000.0
     checkNumericalDispersion: true
     checkCfl: true

   io:
     snapshotMatrix:
       binary: true
       velocity: {freq: 100, fileName: snaps_vp}
       stress:   {freq: 100, fileName: snaps_sp}
     seismogram:
       binary: false
       freq: 4
       receivers: [5,30,55,80,105,130,155,175]

   source:
     signal:
       kind: ricker
       depth: 640.0  # km
       period: 65.0  # seconds
       delay: 180.0  # seconds

   material:
     kind: prem


Which we already prepared and you can get by doing:

.. code:: bash

   cp ${ESWSRCDIR}/demos/fom_rank1/input.yaml ${MYRUNDIR}

Note how the input file is organized into sections:

- *general*: contains general inputs, e.g., where the mesh is, time stepping, etc;

- *io*: contains parameters to collect data, e.g., the snapshot matrix and seismogram;

- *source*: to define the kind of source signal, and its depth with respect to earth surface;

- *material*: defines the type of material to use.


`3. Run the simulation`_
========================

If you just use a build using a serial Kokkos, you can do:

.. code:: bash

   cd ${MYRUNDIR}
   ln -s ${MYWORKDIR}/build/shwave_fom .
   ./shwave_fom input.yaml

**Note** that for a serial build, running this demo should take about 1 minute or so.

If you use an OpenMP build:

.. code:: bash

   cd ${MYRUNDIR}
   ln -s ${MYWORKDIR}/build/shwave_fom .
   OMP_NUM_THREADS=4 OMP_PLACES=threads OMP_PROC_BIND=spread ./shwave_fom input.yaml


`4. Post-process data`_
=======================

Executing the run above should generate inside ``${MYRUNDIR}`` the following files:

.. code:: bash

   coords_sp.txt : coordinates of the velocity grid points
   coords_vp.txt : coordinates of the stresses grid points
   seismogram_0  : seismogram at the receiver locations set in input.yaml
   snaps_vp_0    : snapshot matrix for the velocity
   snaps_sp_0    : snapshot matrix for the stresses


To post-process the data, you can use the Python scripts created for this demo:

.. code:: bash

   cp ${ESWSRCDIR}/demos/fom_rank1/*.py ${MYRUNDIR}


First, we visualize the seismogram data by doing:

.. code:: bash

   cd ${MYRUNDIR}
   python plotSeismogram.py

which should generate a plot like this:

.. figure:: {static}/img/demo1_f1.png

   Sample seismogram generated from this demo.

Second, we can visualize the full wavefield at three times, ``t=1000, 2000`` (seconds) as follows:

.. code:: bash

   cd ${MYRUNDIR}
   ln -s ${MYWORKDIR}/build/extractStateFromSnaps .

   ./extractStateFromSnaps --snaps=./snaps_vp_0 binary \
	  --fsize=1 --outformat=ascii --timesteps=4000 8000 \
	  --samplingfreq=100 --outfileappend=vp

   python plotWavefield.py


which should generate three plots as follows:

.. image-grid::

   {static}/img/demo1_f2.png
   {static}/img/demo1_f3.png
