
#include "./fom/fom_problem_rank_one_forcing.hpp"

template<class T>
std::string checkVp(const T & appObj)
{
  std::string sentinel = "PASS";

  const std::vector<std::vector<double>> goldVp =
    {
      {0.00000000000000000000, 1.00000000000000000000},
      {0.78539816339744827900, 1.00000000000000000000},
      {1.57079632679489655800, 1.00000000000000000000},
      {2.35619449019234483700, 1.00000000000000000000},
      {3.14159265358979311600, 1.00000000000000000000},
      {0.00000000000000000000, 1.25000000000000000000},
      {0.78539816339744827900, 1.25000000000000000000},
      {1.57079632679489655800, 1.25000000000000000000},
      {2.35619449019234483700, 1.25000000000000000000},
      {3.14159265358979311600, 1.25000000000000000000},
      {0.00000000000000000000, 1.50000000000000000000},
      {0.78539816339744827900, 1.50000000000000000000},
      {1.57079632679489655800, 1.50000000000000000000},
      {2.35619449019234483700, 1.50000000000000000000},
      {3.14159265358979311600, 1.50000000000000000000},
      {0.00000000000000000000, 1.75000000000000000000},
      {0.78539816339744827900, 1.75000000000000000000},
      {1.57079632679489655800, 1.75000000000000000000},
      {2.35619449019234483700, 1.75000000000000000000},
      {3.14159265358979311600, 1.75000000000000000000},
      {0.00000000000000000000, 2.00000000000000000000},
      {0.78539816339744827900, 2.00000000000000000000},
      {1.57079632679489655800, 2.00000000000000000000},
      {2.35619449019234483700, 2.00000000000000000000},
      {3.14159265358979311600, 2.00000000000000000000}
    };

  auto vpCoords = appObj.viewCoordsHost(dofId::vp);
  if (vpCoords.extent(0) != goldVp.size()) sentinel = "FAIL";
  if (vpCoords.extent(1) != 2) sentinel = "FAIL";

  for (std::size_t i=0; i<vpCoords.extent(0); ++i)
  {
    // theta is in col = 0
    const auto err0 = std::abs(vpCoords(i,0) - goldVp[i][0]);

    // recall that vpCoords stores in col=1 the inverse of radius in km
    const auto err1 = std::abs(vpCoords(i,1) - 1./(goldVp[i][1]*1000.));

    std::cout << vpCoords(i,0) << " " << goldVp[i][0] << std::endl;
    std::cout << vpCoords(i,1) << " " << 1./(goldVp[i][1]*1000.) << std::endl;
    if (err0 > 1e-13 or err1 > 1e-13){
      sentinel = "FAIL";
      break;
    }
  }

  return sentinel;
}

template<class T>
std::string checkSp(const T & appObj)
{
  std::string sentinel = "PASS";

  const std::vector<std::vector<double>> goldSp =
    {
      {0.00000000000000000000, 1.125000000000000000},
      {0.39269908169872413950, 1.000000000000000000},
      {0.78539816339744827900, 1.125000000000000000},
      {1.17809724509617241850, 1.000000000000000000},
      {1.57079632679489655800, 1.125000000000000000},
      {1.96349540849362069750, 1.000000000000000000},
      {2.35619449019234483700, 1.125000000000000000},
      {2.74889357189106897650, 1.000000000000000000},
      {3.14159265358979311600, 1.125000000000000000},
      {0.00000000000000000000, 1.375000000000},
      {0.39269908169872413950, 1.250000000000000000},
      {0.78539816339744827900, 1.3750000000000000000},
      {1.17809724509617241850, 1.250000000000000000},
      {1.57079632679489655800, 1.3750000000000000000},
      {1.96349540849362069750, 1.250000000000000000},
      {2.35619449019234483700, 1.3750000000000000000},
      {2.74889357189106897650, 1.250000000000000000},
      {3.14159265358979311600, 1.3750000000000000000},
      {0.00000000000000000000, 1.6250000000000},
      {0.39269908169872413950, 1.50000000000000000000},
      {0.78539816339744827900, 1.62500000000000000000},
      {1.17809724509617241850, 1.50000000000000000000},
      {1.57079632679489655800, 1.62500000000000000000},
      {1.96349540849362069750, 1.50000000000000000000},
      {2.35619449019234483700, 1.62500000000000000000},
      {2.74889357189106897650, 1.50000000000000000000},
      {3.14159265358979311600, 1.62500000000000000000},
      {0.00000000000000000000, 1.8750000000000},
      {0.39269908169872413950, 1.75000000000000000000},
      {0.78539816339744827900, 1.87500000000000000000},
      {1.17809724509617241850, 1.75000000000000000000},
      {1.57079632679489655800, 1.87500000000000000000},
      {1.96349540849362069750, 1.75000000000000000000},
      {2.35619449019234483700, 1.87500000000000000000},
      {2.74889357189106897650, 1.75000000000000000000},
      {3.14159265358979311600, 1.87500000000000000000},
      {0.39269908169872413950, 2.00000000000000000000},
      {1.17809724509617241850, 2.00000000000000000000},
      {1.96349540849362069750, 2.00000000000000000000},
      {2.74889357189106897650, 2.00000000000000000000},
    };

  auto spCoords = appObj.viewCoordsHost(dofId::sp);
  if (spCoords.extent(0) != goldSp.size()) sentinel = "FAIL";
  if (spCoords.extent(1) != 2) sentinel = "FAIL";

  for (std::size_t i=0; i<spCoords.extent(0); ++i)
  {
    // theta is in col = 0
    const auto err0 = std::abs(spCoords(i,0) - goldSp[i][0]);

    // recall that spCoords stores in col=1 the inverse of radius in km
    const auto err1 = std::abs(spCoords(i,1) - 1./(goldSp[i][1]*1000.));

    std::cout << spCoords(i,0) << " " << goldSp[i][0] << std::endl;
    std::cout << spCoords(i,1) << " " << 1./(goldSp[i][1]*1000.) << std::endl;
    if (err0 > 1e-13 or err1 > 1e-13){
      sentinel = "FAIL";
      break;
    }
  }

  return sentinel;
}

int main(int argc, char *argv[])
{
  Kokkos::initialize (argc, argv);
  {
    using sc_t = double;
    using parser_t = kokkosapp::commonTypes::parser_t;
    using prob_t = kokkosapp::FomProblemRankOneForcing;
    using app_t  = typename prob_t::fom_t;
    using mesh_info_t = typename prob_t::mesh_info_t;
    using forcing_t = typename prob_t::forcing_t;

    parser_t parser(argc, argv);
    mesh_info_t meshInfo(parser.getMeshDir());
    app_t appObj(meshInfo);

    auto matObj = createMaterialModel<sc_t>(parser, meshInfo);
    appObj.computeJacobians(*matObj);

    const std::string sentinelVp = checkVp(appObj);
    const std::string sentinelSp = checkSp(appObj);

    if (sentinelVp == "PASS" and sentinelSp=="PASS"){
      std::puts("PASS");
    }
    else{
      std::puts("FAIL");
    }
  }
  Kokkos::finalize();

  return 0;
}
